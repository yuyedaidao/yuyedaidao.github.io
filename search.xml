<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IBInspectable无法取值的问题]]></title>
    <url>%2F2018%2F11%2F09%2FIBInspectable%E6%97%A0%E6%B3%95%E5%8F%96%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[我在xib文件里用了IBInspectable然后在UIView的layoutSubviews里执行 dispatch_async(dispatch_get_main_queue(), ^{ //some code} 竟然取不到相应IBInspectable标记的值，如果在block的外边重新声明新的变量并赋值才可以如图： 奇怪的问题，特此记录]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WCSession-sendMessage-失败处理]]></title>
    <url>%2F2018%2F11%2F09%2FWCSession-sendMessage-%E5%A4%B1%E8%B4%A5%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[通过手表向手机端发送消息时出现Payload could not be delivered(中文环境下:未能传送负载)的错误提示,如果你保证你的设置都对的情况下,请记得检查手机端WCSession实现的代理方法全不全 如果你是这样发送消息 session.sendMessage([&quot;request&quot; : &quot;list&quot;], replyHandler: nil, errorHandler: { (error) in print(error)}) 那么在手机端你要有这样的代理方法 public func session(_ session: WCSession, didReceiveMessage message: [String : Any]) 如果你是这样发送消息 session.sendMessage([&quot;request&quot; : &quot;list&quot;], replyHandler: { (result) in print(result) }, errorHandler: { (error) in print(error) }) 那么在手机端你要有这样的代理方法 public func session(_ session: WCSession, didReceiveMessage message: [String : Any], replyHandler: @escaping ([String : Any]) -&gt; Swift.Void) 根据发送时有没有replyHandler来决定调用哪个代理方法,如果不匹配就会发送失败]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>exception</tag>
        <tag>iOS</tag>
        <tag>watch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VS保存时自动格式化导致ejs编译错误]]></title>
    <url>%2F2018%2F11%2F09%2FVS%E4%BF%9D%E5%AD%98%E6%97%B6%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AF%BC%E8%87%B4ejs%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[ejs模板引擎不知道大家有没有好的格式化插件,有的话,求一个最近遇到一个ejs解析的问题,非常小心的写好ejs文件,一运行出了错,如下12345678Invalid or unexpected token in /Users/wang/Desktop/Work/Node/nobook/views/web-index.ejs while compiling ejs If the above error is not helpful, you may want to try EJS-Lint: https://github.com/RyanZim/EJS-LintSyntaxError: Invalid or unexpected token in /Users/wang/Desktop/Work/Node/nobook/views/web-index.ejs while compiling ejsIf the above error is not helpful, you may want to try EJS-Lint:https://github.com/RyanZim/EJS-Lint at new Function (&lt;anonymous&gt;)... 完全看不到有用的信息,shit 于是我就按提示用 https://github.com/RyanZim/EJS-Lint 来试试能不能看到更多信息…心累啊,用命令号执行直接返回了没有任何信息.加在工程里返回undefined, MMP.姿势不对?有掌握动作要领的请指教. 在折磨了接近两天的时间后我不得对我接近千行的ejs文件一行行ejs代码进行查看,还是没错啊…要你你能不崩溃? 最最后,我就重新把带有ejs代码的片段一段段摘出来,然后一遍遍部署运行,终于…苍天啊. 1&lt;a href=&quot;javascript:void(0)&quot; onclick=&lt;%- &apos;\&apos;deleteAlert( &quot;&apos;+ item.name + &apos;&quot;, &quot;&apos; + item._id + &apos;&quot;) \ &apos;&apos; %&gt; 如上这就是问题代码,估计再细心你可能也没法很多发现问题吧…其实我的原始代码是1&lt;a href=&quot;javascript:void(0)&quot; onclick=&lt;%- &apos;\&apos;deleteAlert( &quot;&apos;+ item.name + &apos;&quot;, &quot;&apos; + item._id + &apos;&quot;) \&apos;&apos; %&gt; 发现了,他妈的最后一个转义斜杠\后边接了个空格…wtf.而这都是我在保存时vs给我自动格式化造成的. 说了太多脏话.反思]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>exception</tag>
        <tag>vs</tag>
        <tag>ejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIImagePickerController不走回调的问题]]></title>
    <url>%2F2018%2F11%2F09%2FUIImagePickerController%E4%B8%8D%E8%B5%B0%E5%9B%9E%E8%B0%83%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天又遇到了一个奇怪的问题代码如下： 12345UIImagePickerController *imagePicker = [[UIImagePickerController alloc] init];imagePicker.allowsEditing = YES;imagePicker.sourceType = UIImagePickerControllerSourceTypePhotoLibrary;imagePicker.delegate = self;[self presentViewController:imagePicker animated:YES completion:nil]; 用法很对，没毛病，可就是不调用1-(void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info 分析原因 UIImagePickerController实例对象被释放了 //这不可能，如果iOS系统没疯那肯定是我疯了 UIImagePickerControllerd的delegate被释放了 //但是delegate是当前视图控制器肯定也没有释放 delegate被改了 //看了看代码没有改动的地方啊 ???诡异的事件。。。 后来我用kvo监测了一下delegate，发现果然被改了，改成了 _JZNavigationDelegating … 真相大白原来是我在pod里加入了一个帮助处理NavigationBar颜色的第三方库，这个库对UINavigationController做了一些处理，如下图 而我们今天的主角 UIImagePickerController恰恰就是UINavigationController的子类]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>exception</tag>
        <tag>iOS</tag>
        <tag>imagePicker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoreData里UUID的奇怪问题]]></title>
    <url>%2F2018%2F11%2F09%2FCoreData%E9%87%8CUUID%E7%9A%84%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[0x1今天我在开发AppleWatch应用时发现了一个关于CoreData的极其古怪的问题,特此记录下来 0x2因为CoreData是支持UUID类型的属性的,所以我在设计某个Model时就用了UUID的属性,但是因为不是连续开发导致我后来把这个属性的类型忘了,以为是String. 于是我在手机端的代码里写了类似这样的代码123let uuid: String = &quot;7BD09D86-8941-4E50-9A42-7240E970FEE7&quot;let predicate = NSPredicate(format: &quot;uuid = %@&quot;, argumentArray: [uuid])//省略CoreData根据predicate获取数据的代码 注意Model里uuid的属性类型是UUID,我在这里直接用的是String然后,我…很成功的获取到了预期的数据.当然,我当时并没有意识到类型不匹配. 于是乎,我把相同的代码放到了12//MARK: -WCSession的代理方法 Watch向iPhone发送的消息在这里接收 func session(_ session: WCSession, didReceiveMessage message: [String : Any], replyHandler: @escaping ([String : Any]) -&gt; Void) 然后,我怎么也获取不到数据了,一模一样的代码,我曾一度变成了有神论者,简直诡异至极….获取数据的方法我放在什么线程里都不行,这个代理函数的执行环境我不知道跟主应用的程序执行环境有什么不同 0x3结果到目前为止大家肯定已经知道了,就是把查询时的String类型的uuid修改成UUID类型 0x4原因未知]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CoreData</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CADisplayLink不销毁导致其拥有者也不释放]]></title>
    <url>%2F2018%2F11%2F09%2FCADisplayLink%E4%B8%8D%E9%94%80%E6%AF%81%E5%AF%BC%E8%87%B4%E5%85%B6%E6%8B%A5%E6%9C%89%E8%80%85%E4%B9%9F%E4%B8%8D%E9%87%8A%E6%94%BE%2F</url>
    <content type="text"><![CDATA[我发现我在拥有CADisplayLink且其没有invilidate的情况下，会让其所有者没法销毁]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>exception</tag>
        <tag>iOS</tag>
        <tag>CADisplayLink</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么dispatch_sync在主线程会死锁]]></title>
    <url>%2F2018%2F11%2F09%2F%E4%B8%BA%E4%BB%80%E4%B9%88dispatch-sync%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%BC%9A%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[首先看下面一段代码 dispatch_queue_t queue = dispatch_queue_create(&quot;abc&quot;, DISPATCH_QUEUE_SERIAL); dispatch_sync(queue, ^{//taskA //do something dispatch_sync(queue, ^{//taskB //啥也干不了 }); }); dispatch_sync函数用于将一个block(任务)提交到队列中同步执行，直到block执行完后，这个函数才会返回。queue是一个串行队列，如果先后加入两个任务，taskA和taskB, 那么只有taskA执行完之后taskB才能执行。如果taskB是在taskA中加进队列的，那么它们依然遵守先进先出原则，即taskA执行完之后taskB才执行，也就是taskB在等待taskA完成。但是因为dispatch_sync的同步特性,taskB执行不完taskA就不算完成，即taskA在等待taskB的完成，这样就发生了死锁。 根据上面那份代码，我们就可以理解下面的代码为什么会阻塞主线程了。 dispatch_queue_t mainQueue = dispatch_get_main_queue(); dispatch_sync(mainQueue, ^{ NSLog(@&quot;hello&quot;); }); mainQueue是系统创建的，在执行上面的代码之前就已经加进去了很多任务 dispatch_queue_t queue = dispatch_queue_create(&quot;Main&quot;, DISPATCH_QUEUE_SERIAL); dispatch_sync(queue, ^{ //Task A }); ... dispatch_sync(queue, ^{ //Task N }); 在这N个任务里有一个任务是这样的： dispatch_sync(queue, ^{ dispatch_queue_t mainQueue = dispatch_get_main_queue(); dispatch_sync(mainQueue, ^{ NSLog(@&quot;hello&quot;); }); }); 所以，发生死锁就是必然的了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于连续触发的函数中动画异常的描述]]></title>
    <url>%2F2018%2F11%2F09%2F%E5%85%B3%E4%BA%8E%E8%BF%9E%E7%BB%AD%E8%A7%A6%E5%8F%91%E7%9A%84%E5%87%BD%E6%95%B0%E4%B8%AD%E5%8A%A8%E7%94%BB%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8F%8F%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[我想要的过程是这样的，我有两个label像球场上的广告牌一样交替滚动，当前的往上移动逐渐消失下边的从下边同时往上移动逐渐出现。我为了在autolayout下也能实现所以一开始准备用transform实现，但是发现往上移动的动画异常，不知道什么原因，让人郁闷。。。便秘的感觉很久之后，我决定退而求其次，用改变center来实现，问题解决了，但是是建立在我这两个label没有autolayout的基础之上。今天特此记下，留待以后研究。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>exception</tag>
        <tag>iOS</tag>
        <tag>autolayout</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿QQ左侧滑动菜单的实现]]></title>
    <url>%2F2018%2F11%2F09%2F%E4%BB%BFQQ%E5%B7%A6%E4%BE%A7%E6%BB%91%E5%8A%A8%E8%8F%9C%E5%8D%95%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[##冲动最近接手的一个老项目有个侧滑菜单的需求，这个老项目的侧滑菜单用了网络上的一个第三方库，但是这个库竟然没有处理好导航条的显示，以至于项目中很多需要导航条展示信息的视图都通过添加subView的方式模仿了导航条。这简直是暴殄天物啊，放着真正的导航栏那强大的作用不用，浪费了多少时间和精力啊，都是青春啊，开发的前路上早已挖了无数的坑等着身心疲惫的我们往里跳啊。对此深恶痛绝的我，早就下了不杀此贼誓不罢休的决心。好吧，最近看三国看的有点多了。 ##暗渡陈仓我在无所不能的GitHub上搜索侧滑菜单项目，试验了各种，发觉没有能很好的符合当前项目需求。我们当前的项目需求是跟手机QQ左侧滑动菜单一样的效果，有个默认的主视图，然后其他视图的展示都是在这个视图的基础上push出来的。当然把这些项目改造出这种功能其实也不难，但是左侧菜单的视差效果都跟QQ相差甚远，唯一相似的就是RESideMenu这个比较有名的项目，但是它的视差效果是菜单在展示过程中由比较大然后缩放到实际大小，感觉不如QQ的效果好，怎奈我当时心情比骄傲浮躁，改了个参数也没调出想要的效果来，于是一怒之下决定自己写一个。事后，发现有个Swift版的特别炫酷，完全模仿的QQ，点这里查看 大哭，此大神还有相应的教程，如果各位看官不想听我接下来的实现思路又能看懂Swift的可以瞬移到此大神的博客了。 ##思路不送….. 呜呜呜……先看我寒碜的效果 实在忍不了，换了小图了 哎，炫酷没法比啊。 iOS5之后每个UIViewController都可以轻松当一个容器了，可以同时管理许多其他的UIViewController了。 addChildViewController: willMoveToParentViewController: didMoveToParentViewController: 拿去，不谢！具体怎么写一个容器不在本文的讨论重点，还请大家自行谷歌。好吧，我是在用红杏翻墙 软广取消，红杏被郭嘉干掉后我的钱也追不回来了 现在的话我有两个子视图控制器了，把他们的view分别放在了我自定义的menuViewContainer和contentViewContainer这两个View里。OK，基础已打好。理所应当，我在contentViewCcontainer上添加一个滑动手势，滑动时移动视图的位置就行了。那怎么确定手指在滑动时相应的视图应该滑动到哪呢？滑动到哪里结束呢？怎么确定同时改缩放到什么程度呢？这些问题我本来想一一说讲一遍，发现自己太啰嗦，又不知道该怎么讲，所以还是直接上代码吧。 - (void)panGestureRecognizer:(UIScreenEdgePanGestureRecognizer *)recognizer{ CGPoint point = [recognizer translationInView:self.view]; if(recognizer.state == UIGestureRecognizerStateBegan) { [self updateContentViewShadow]; }else if(recognizer.state == UIGestureRecognizerStateChanged){ CGFloat menuVisibleWidth = self.view.bounds.size.width-self.realContentViewVisibleWidth; CGFloat delta = self.menuHidden ? point.x/menuVisibleWidth : (menuVisibleWidth+point.x)/menuVisibleWidth; CGFloat scale = 1-(1-MinScaleContentView)*delta; CGFloat menuScale = MinScaleMenuView + (1-MinScaleMenuView)*delta; if(self.menuHidden){ //以内容视图最小缩放为界限 if(scale &lt; MinScaleContentView){//A self.contentViewContainer.transform = CGAffineTransformMakeTranslation(menuVisibleWidth, 0); self.contentViewContainer.transform = CGAffineTransformScale(self.contentViewContainer.transform,MinScaleContentView,MinScaleContentView); self.contentViewScale = MinScaleContentView; self.menuViewContainer.transform = CGAffineTransformMakeScale(1, 1); self.menuViewContainer.transform = CGAffineTransformTranslate(self.menuViewContainer.transform, 0, 0); }else{//大于最小界限又分大于等于1和小于1两种情况 if(scale &lt; 1){//B self.contentViewContainer.transform = CGAffineTransformMakeTranslation(point.x, 0); self.contentViewContainer.transform = CGAffineTransformScale(self.contentViewContainer.transform,scale, scale); self.contentViewScale = scale; self.menuViewContainer.transform = CGAffineTransformMakeScale(menuScale, menuScale); self.menuViewContainer.transform = CGAffineTransformTranslate(self.menuViewContainer.transform, -MoveDistanceMenuView *(1-delta), 0); }else{//C self.contentViewContainer.transform = CGAffineTransformMakeTranslation(0, 0); self.contentViewContainer.transform = CGAffineTransformScale(self.contentViewContainer.transform,1, 1); self.contentViewScale = 1; self.menuViewContainer.transform = CGAffineTransformMakeScale(MinScaleMenuView, MinScaleMenuView); self.menuViewContainer.transform = CGAffineTransformTranslate(self.menuViewContainer.transform, -MoveDistanceMenuView, 0); } } }else{ if(scale &gt; 1){//D self.contentViewContainer.transform = CGAffineTransformMakeTranslation(0, 0); self.contentViewContainer.transform = CGAffineTransformScale(self.contentViewContainer.transform,1,1); self.contentViewScale = 1; self.menuViewContainer.transform = CGAffineTransformMakeScale(MinScaleMenuView, MinScaleMenuView); self.menuViewContainer.transform = CGAffineTransformTranslate(self.menuViewContainer.transform, -MoveDistanceMenuView, 0); }else{ if(scale&gt;MinScaleContentView){//E self.contentViewContainer.transform = CGAffineTransformMakeTranslation(point.x+menuVisibleWidth, 0); self.contentViewContainer.transform = CGAffineTransformScale(self.contentViewContainer.transform,scale, scale); self.contentViewScale = scale; self.menuViewContainer.transform = CGAffineTransformMakeScale(menuScale, menuScale); self.menuViewContainer.transform = CGAffineTransformTranslate(self.menuViewContainer.transform, -MoveDistanceMenuView * (1-delta), 0); }else{//F self.contentViewContainer.transform =CGAffineTransformMakeTranslation(self.view.bounds.size.width-self.realContentViewVisibleWidth, 0); self.contentViewContainer.transform = CGAffineTransformScale(self.contentViewContainer.transform,MinScaleContentView, MinScaleContentView); self.contentViewScale = MinScaleContentView; self.menuViewContainer.transform = CGAffineTransformMakeScale(1, 1); self.menuViewContainer.transform = CGAffineTransformTranslate(self.menuViewContainer.transform, 0, 0); } } } }else if(recognizer.state == UIGestureRecognizerStateEnded){ [self showMenu:(self.contentViewContainer.frame.origin.x &gt; self.view.bounds.size.width/2)]; } } 这样的结尾是不是太不负责任了？？？好吧，我提醒大家，整段代码的精华全在delta的计算，视图滑动后的最终状态是由menuVisibleWidth和MinSacleContentView来决定。根据当前手势滑动的距离占menuVisibleWidth的百分比来计算滑动动作完成度，然后根据这个值来移动和缩放相应的视图。 最后，上我的项目地址，如果大家不嫌弃，请给star，如果有问题，烦请留言。感激涕零]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回头看UITableView(三)-下拉刷新的实现]]></title>
    <url>%2F2018%2F11%2F09%2F%E5%9B%9E%E5%A4%B4%E7%9C%8BUITableView-%E4%B8%89-%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[最近陷入了项目中一个日历月视图与周视图切换效果的实现，长时间没有实现想要的效果，沮丧至极。烦请有好想法的同学指点一二，在线等@留什么白。 结束例行的啰嗦，进入正题。 大家可能都用过MJRefresh,十分之方便，李明杰老师借助runtime的特性，极尽之能，让千千万万小白开发者和遵循不重复制造轮子原则的开发者用最少的代码就实现了界面下拉刷新的功能。我们今天不谈runtime的黑魔法，而是UITableView最常见的刷新数据方式下拉刷新的实现过程。 首先，我们定义三个枚举值 typedef NS_ENUM(NSUInteger, RefreshState) { RefreshStateNormal,//正常 RefreshStatePulling,//释放即可刷新 RefreshStateLoading,//加载中 }; 分别表示正常状态、释放即可刷新状态、加载中状态 为了简单说明，我们只用一个UILabel来表现就可以，把它放在内容上方，也就是正常情况下看不到的地方，只有下拉的时候才能看到。 然后我们估算一个大体的距离，从而确定触发加载状态的临界点。 简单描述一下将要实现的情形： 我们往下滑动视图，如果视图下滑到触发点，状态变为RefreshStatePulling,即标签文字变为“松手即可刷新”。接下来有两种状况会发生：一，松开手；二，不松手，又向初始位置滑。第一种情况，当你松开手时，因为UIScrollView有回弹效果，视图会往上滑动，当到达触发点时，状态改为RefreshStateLoading,即视图停在当前位置，不受回弹作用影响，标签文字变为“加载中…”,等加载动作完成之后，手动触发复原动作，视图滑到原始状态 RefreshStateNormal,同时标签文字变为‘下拉刷新’；第二种情况，你没有松手，然后又往回滑动，当到达触发点以上时，状态变为初始状态RefreshStateNormal。 如果你对上述过程不是很了解的话，那你随便找个带下拉刷新的应用试试就行了，不用温柔，越暴力越好。弄清上述过程是实现整个流程的基础。 接下来要做的就是决定什么时候改变状态了，参照上述过程，我们在UIScrollView的代理函数scrollViewDidScroll:监控contentOffset的变化，再结合isDragging属性就可以改变状态了。 - (void)scrollViewDidScroll:(UIScrollView *)scrollView{ if(scrollView.contentOffset.y &lt; -SwitchPoint-self.originalInsetTop){ if(self.refreshState == RefreshStateNormal){//小于临界值（在触发点以下），如果状态是正常就转为下拉刷新，如果正在刷新或者已经是下拉刷新则不变 self.refreshState = RefreshStatePulling; } }else{//大于临界值（在触发点以上，包括触发点） if(scrollView.isDragging){//手指没有离开屏幕 if(self.refreshState == RefreshStatePulling){//原来是下拉的话变成正常，原来是刷新或者正常的话不变 self.refreshState = RefreshStateNormal; } }else{//手指离开屏幕 if(self.refreshState == RefreshStatePulling){//原来是下拉的话变成加载中，原来是加载中或者正常的话不变 self.tableView.contentInset = UIEdgeInsetsMake(self.originalInsetTop+SwitchPoint, 0, 0, 0);//改变contentInset的值就可以取消回弹效果停留在当前位置了 关于contentIinset的介绍，可以查看我的上一篇文章 self.refreshState = RefreshStateLoading; } } } } 这段代码决定了UIScrollView每个时刻的状态，那么接下来的就简单多了，只要重写一下setRefreshState:方法就可以了。 - (void)setRefreshState:(RefreshState)refreshState{ _refreshState = refreshState; switch (refreshState) { case RefreshStateNormal: self.pulldownLabel.text = @&quot;下拉刷新&quot;; [self.pulldownLabel sizeToFit]; break; case RefreshStateLoading: self.pulldownLabel.text = @&quot;正在刷新...&quot;; [self.pulldownLabel sizeToFit]; if(self.refreshBlock){ self.refreshBlock();//这里就是你要执行的耗时的操作 } break; case RefreshStatePulling: self.pulldownLabel.text = @&quot;松开即可刷新&quot;; [self.pulldownLabel sizeToFit]; break; default: break; } } 看一下我们的效果：当然你会说这不够diao,不够炫酷，人家的效果都是这样： 又被你发现了，😂，我满(hao)是(wu)虔(jie)诚(cao)地盗了大神的图，@M了个J，大神，膝盖已发货，请验收。 那么我们怎么实现这样的效果呢，很简单，在上边设置状态的代码里添加动画就行了。来一段伪的代码： case RefreshStateNormal: self.pulldownLabel.text = @&quot;下拉刷新&quot;; [UIView animateWithDuration:0.3 animations:^{ self.arrowImage.transform = CGAffineTransformMakeRotation(M_PI/2);//箭头旋转180º }]; break; 还有一点需要强调，在scrollViewDidScroll:里保持加载状态时修改了contentInset,所以取消加载状态恢复原状时只需…如此如此： - (void)endRefresh{ if(self.refreshState == RefreshStateLoading){ self.refreshState = RefreshStateNormal; [UIView animateWithDuration:0.3 animations:^{ self.tableView.contentInset = UIEdgeInsetsMake(self.originalInsetTop, 0, 0, 0); } completion:nil]; } } OK，希望看到这里你能理解下拉刷新的整个过程及原理了，欢迎指正和打击。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>UITableView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回头看UITableView(二)-父视图UIScrollView]]></title>
    <url>%2F2018%2F11%2F09%2F%E5%9B%9E%E5%A4%B4%E7%9C%8BUITableView-%E4%BA%8C-%E7%88%B6%E8%A7%86%E5%9B%BEUIScrollView%2F</url>
    <content type="text"><![CDATA[题目早早就定下了，现在想填充内容了，踌躇中却不知道从哪里开始了。窗外突然下起雨来。虽然不愿承认，但夏天确实已经渐去渐远，凉意开始蔓延。索性放空身心，伴着雨声入眠吧。 I’m back! 众所周知，UITableView的父视图就是UIScrollView,UITableView之所以能滚动就是基于UIScrollView的特性，今天咱们就来深入理解一下UIScrollView。 上图： 打码： - (IBAction)boundsAction:(UIStepper *)sender { self.redView.bounds = CGRectMake(0, sender.value, self.redView.bounds.size.width, self.redView.bounds.size.height); self.boundsLabel.text = [NSString stringWithFormat:@&quot;红色视图bounds%@&quot;,NSStringFromCGRect(self.redView.bounds)]; } 我如果说改变bounds的值不用UIStepper实现而是用手势实现，不知道大家有没有种恍然大悟的感觉。 我们再复习一下UIView的frame和bounds是什么。. frame:当前view在父view坐标体系中的位置和大小. bounds:当前view的坐标体系，容纳子view的位置和大小也就说一个view的位置是由当前view的frame和其父view的bounds决定的。 回到上面的红绿视图，你已经看到:改变父view（红色视图）的bounds,子view（绿色视图）的位置就会相应的改变。如果我们给红色视图加一个UIPangestureRecognizer（拖动手势），滑动时根据其代理函数返回的值修改红色视图的bounds就实现了绿色视图的滑动。 再上图：再打码： - (IBAction)panHandler:(UIPanGestureRecognizer *)sender { if(sender.state == UIGestureRecognizerStateChanged){ CGFloat distance = -[sender translationInView:sender.view].y; self.redView.bounds = CGRectMake(0, self.redView.bounds.origin.y+distance, self.redView.bounds.size.width, self.redView.bounds.size.height); [sender setTranslation:CGPointZero inView:sender.view]; }else if(sender.state == UIGestureRecognizerStateEnded){ self.boundsLabel.text = [NSString stringWithFormat:@&quot;红色视图bounds%@&quot;,NSStringFromCGRect(self.redView.bounds)]; } } 果然图多可以少说话。那么你是不是可以自己手动写个UIScrollView了，如果你敢回答不能我就敢一星期不吃肉。顺便推荐一个录屏软件，个人感觉很好用，直接生成体积较小的gif。地址是http://www.cockos.com/licecap/ 当然，对于这个能滑动的视图的始祖，我们要想有强烈的掌控感，还需要了解几个属性。 contentSize 😓 又要提到上图了，好吧，如上图，contentSize其实就是绿色视图的大小，就是内容空间的大小。在UIScrollView里，当contentSize大于本身的frame.size的时候就可以滚动，否则不允许。 contentOffset 还是如上图，contentOffset其实就是红色视图的bounds.origin,所以你是否明白为什么当contentOffset的值是正值的时候视图往上，是负值的时候视图往下了吧。 contentInset这个属性很难说清楚，所以，那就更应该说了。如果你设置了这个属性后会对内容视图做一个偏移操作，或者说给内容视图添加了留白，比如说我们设置UIScrollView的contentInset为UIEdgeInsetsMake(64, 0, 0, 0)注意第一个参数是top,然后依次是left,bottom,right。那么添加的subview的位置纵坐标的起点就是subview.frame.origin.y+scrollView.contentInset.top(当然这是在不考虑父视图的bounds的情况下)。你也许注意到了一点，我用了位置一词，因为这其实是相对父视图的位置，它的frame并没有改变。 啊哈哈， self.scrollView.contentInset = UIEdgeInsetsMake(50, 0, 0, 0); UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 50, self.scrollView.bounds.size.width, 200)]; view.backgroundColor = [UIColor greenColor]; [self.scrollView addSubview:view]; 如图，虽然view的起点是50，但是由于contentInset的原因，它相对于父视图的纵坐标位置是100。 好了，先写到这里，办公室就我一个人了，兄弟我先回家了。 预告：根据上边这些东东，咱们稍后谈谈怎么实现一个自定义的下拉刷新控件，我会尽快更新。最后，诚心求一个Mac上方便作图的软件。如果你有破解版的sketch的话，给兄弟一个吧，先谢过了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>UITableView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回头看之UITableView-(基本代理方法及复用原理)]]></title>
    <url>%2F2018%2F11%2F09%2F%E5%9B%9E%E5%A4%B4%E7%9C%8B%E4%B9%8BUITableView-%E5%9F%BA%E6%9C%AC%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95%E5%8F%8A%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[UITableVIew是iOS开发中最常见的视图中最经典的视图了，没有之一，相信对这个视图敢称精通的人开发个好应用应该是问题不大的。 闲话少叙，进入正题。 怎么使用掌握两个代理 UITableViewDelegate @optional //下文再提到该方法用heightForRow代替 - (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath; UITableViewDataSource @required //下文再提到该方法用numberOfRowsInSection代替 - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section; //下文再提到该方法用cellForRow代替 - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath; @optional //下文再提到该方法用numberOfSection代替 - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView 要想比较完整的展示你的数据，这四个方法是最经常被实现的。调用过程大体是这样的：tableView会先询问代理(在一般MVC里大部分是当前视图控制器ViewController)要展示多少个section,就是调用numberOfSections,如果代理没有实现该方法默认就是1个section。然后tableView调用numberOfRowsInSection先询问第一个section有多少个cell,然后挨个执行heightForRow获取每个cell的高度。tableView对每个section都执行一遍这样的操作后，那么结果来了:tableView通过对这些cell高度的累加就知道了需要多大的空间才能安放得了所有的内容，于是它调整好了contentSize的值。这样走下来就为我们后续在滑动时能通过scrollIndicator观察到我们大体滑到了哪个位置做好了准备。准备好空间之后接下来的任务就是准备内容了。当然大家都知道真正的内容是依附在UITableViewCell上的，tableView先调用cellForRow去获取代理返回给它的第一个cell，对于所有的cell来说width都是固定的，即tableView本身的宽度，对于第一个cell来说它的origin也是确定的，即(0,0)，也就是说要想确定这个cell的位置就只需要知道它的height了。于是tableView再去调用heightForRow去获取它的高度，这样一个视图能确定显示在屏幕什么位置的充要条件就具备了。剩下的cell同理，挨个放在上一个cell的下边就行了。 总结一下: 调用numberOfSection获得 A个 section 先调用numberOfRowsInSection获得B个cell,再调用heightForRowB次。如此循环A次 循环调用cellForRow和heightForRow，直到cell的个数充满当前屏幕。 这就是一个普通的tableView一开始加载数据的过程，有几点需要说明： 如果你展示在每个cell上的内容是相对固定的，准确点说是每个cell的高度是固定的，那么heightForRow是不建议让代理去实现的，而是通过tableView的rowHeight属性来代替，当数据量比较大，比如说有10000个(其实只要 &gt;= 2)cell时，tableView只需要10000*rowHeight就知道应该准备的空间大小了，而不是调用一个方法10000次通过累加获知需要的大小。而且你懂的，要想获取一个cell的高度并不是那么容易的事，尤其是在自动布局出现之前，你需要计算各种字符串的所占空间的大小，这对性能是相当大的损耗。 如果每个cell高度确实不一样，数据量又很大时该怎么解决这个性能问题呢，iOS7之后系统提供了估算高度的办法，estimatedRowHeight和- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath//下文再提到该方法用estimateHeightForRow代替,这样每次在加载数据之前，tableView不再通过heightForRow消耗大量的性能获取空间大小了，而是通过在estimateRowHeight或者estimatedHeightForRow不需要费劲计算就能获取的一个估算值来获取一个大体的空间大小，等到真正的加载数据时才根据获取真实数据，并做出相应的调整，比如contentSize或者scrollIndicator的位置。关于动态计算高度，推荐羊教授的一篇文章优化UITableViewCell高度计算的那些事 这些方法的调用在保证大顺序不变的情况下，每个方法的调用次数是不一定的，每个iOS版本又不一样，你如果想知道可以动手去试验一下。尤其是在iOS8,它认为cell会随时变化，所以一滑动就重新计算cell的高度。 这些方法的调用其实也是有插曲的，比如调用了reloadData之后，tableView只会调用能让它知道所需空间大小的代理方法，然后立马执行reloadData之后的语句，也就说cellForRow并不会在reloadData之后紧接着执行。所以reloadData之后尽量避免对数据源数组的操作。 复用机制了解UITableView的人肯定对这一著名特性多少有点了解。咱们先假设UITableView没有复用机制，那么我们要展示10000条数据的话，那就得生成10000个UITableViewCell,占用了大量内存不说，性能也可想而知了，必然是一滑一卡顿，一顿一暴怒啊，控制力弱的估计要摔手机了。 复用机制大体是这样:UITableView首先加载一屏幕(假设UITableView的大小是整个屏幕的大小)所需要的UITableViewCell,具体个数要根据每个cell的高度而定，总之肯定要铺满整个屏幕,更准确说当前加载的cell的高度要大于屏幕高度。然后你往上滑动，想要查看更多的内容，那么肯定需要一个新的cell放在已经存在内容的下边。这时候先不去生成，而是先去UITableView自己的一个资源池里去获取。这个资源池里放了已经生成的而且能用的cell。如果资源池是空的话才会主动生成一个新的cell。那么这个资源池里的cell又来自哪里呢？当你滑动时视图是，位于最顶部的cell会相应的往上滑动，直到它彻底消失在屏幕上，消失的cell去了哪里呢？你肯定想到了，是的，它被UITableView放到资源池里了。其他cell也是这样，只要一滑出屏幕就放入资源池。这样，有进有出，总共需要大约一屏幕多一点的cell就够了。相对于1000来说节省的资源就是指数级啊，完美解决了性能问题。 iOS6之后我们一般在代码里这样处理cell 先注册 [self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:@&quot;UITableViewCell&quot;]; 或 [self.tableView registerNib:[UINib nibWithNibName:@&quot;NibTableViewCell&quot; bundle:nil] forCellReuseIdentifier:@&quot;NibTableViewCell&quot;]; 在代理方法里获取 - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{ UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;UITableViewCell&quot; forIndexPath:indexPath]; // do something return cell; } 那么具体在代码里是怎么实现的呢？我们可以大胆的猜测一下。 UITableView有几个属性(假想的)： NSMutableDictionary *registerCellInfo; NSMutableDictionary *reusableCellsDictionary; NSMutableArray *visibleCells; 我们推测两个注册方法的实现 - (void)registerNib:(UINib *)nib forCellReuseIdentifier:(NSString *)identifier{ [self.registerCellInfo setObject:nib forKey:identifier]; [self.registerCellsDictionary setObject:[NSMutableArray array] forKey:identifier]; } - (void)registerClass:(Class)cellClass forCellReuseIdentifier:(NSString *)identifier{ [self.registerCellInfo setObject:cellClass forKey:identifier]; [self.registerCellsDictionary setObject:[NSMutableArray array] forKey:identifier]; } 然后推测最关键的获取方法 - (UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath{ //indexPath这个参数是为了重置`cell`的大小，相关的处理并不是本文的重点，所以暂不实现 NSMutableArray *array = self.reusableCellsDictionary[identifier]; UITableViewCell *cell = nil; if(array.count){ cell = array.lastObject; [self.visibleCells addObject:cell]; [array removeLastObject]; }else{ id obj = self.registerCellInfo[identifier]; if([obj isKindOfClass:[UINib class]]){ cell = [[((UINib *)obj) instantiateWithOwner:nil options:nil] lastObject]; }else{ cell = [[(Class)obj alloc] init]; } if(cell){ [self.visibleCells addObject:cell]; } } return cell; } 😂，请忽略以上所有推测方法的不严谨，许多该有的条件判断并没有去处理。但是写到这里相信亲爱的读者已经了解了UITableView复用机制的原理了。现在，你已经具备了自己动手写一个UITableView的基础了(当然，假设你已经对UIScrollView有了充足的了解)。如果我的文章对你有用，烦请点个喜欢，好激励我继续写下去。。。 关于UITableView的更多知识我们后续再谈]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>UITableView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS学习笔记]]></title>
    <url>%2F2018%2F11%2F09%2FiOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[autoLayout Autolayout的作用非常明确：帮我们确定在不同设备、不同（父view）环境下，同一个可视单元所应具有合适的位置和尺寸，因此，当一个UIView上所施加的约束能够唯一确定它的frame（x, y, width, height）的时候我们的自动布局的使用才是正确的。而新手通常犯的两类错误就是约束不足（约束太少）和约束冲突两种（约束太多）。如果你给出的约束只能够确定这个view的大小，或者位置或者位置中的某一个项（比如x）的时候，就会出现约束不足的情况，在xib或者storyboard中，会以黄色的警告出现在左侧提示框内；如果你给出的约束推导出了两个甚至多个互相矛盾的位置尺寸结果的时候，就产生了布局错误，在编译的时候直接就build不过。 在画布中角度是顺时针转的 引用 在绘制的方法中，使用 UIGraphicsBeginImageContextWithOptions 来取代 UIGraphicsGetCurrentContext 出处 应用间相互调用只要知道双方设置好的URL就行了，打开另一个应用时可以把当前应用的URL传过去，要打开的应用就可以根据响应的代码就可以让用户触发返回原始应用了 事件的响应链是从子视图到父视图层层传递的，模式是子视图调用父视图相同的方法（[super XXX]），所以触发该事件的先后顺序应该是从父视图到子视图，当然这是默认情况，如果你重写了事件方法，就可以控制是否把事件传递给父视图，或者哪个视图先触发事件上面的理解貌似不够准确，重新整理如下：. 事件链的建立 简单讲是发生在addSubView时，被添加的视图的nextResponder(下一个响应者)就是它的父视图。如果一个veiw(下面简称A)不是普通的view，它是某个viewcontroller的根veiw,那么A的nextResponder在A从初始化完后就赋值为viewController。然后当A被addsubview到rootview的时候(addChildViewController时会发生)，Controller A的nextresponder被复制为rootview。. 事件的传递 当用户触摸时，UIKit先创建一个事件对象，加到事件队列中去，然后UIAPPlication从中取出来，从window开始查找，发现点击位置在window的范围内，那就继续查找window的subViews,直到找到视图树最顶部的叶子视图，然后把事件交给这个顶部视图，视图处理事件，如果不处理就交给它的nextResponser,层层往下，直到window再到UIApplacation。 像素就是一个小点，px就表示一个真正的点，pt就是标准中定好的有大小的点,1/72英寸,分辨率是指指每单位面积（平方英寸）像素的个个数，即dpi,之所以谈到具体的设备时经常用W*H表示分辨率，是用了当前设备的长宽方向上的像素除以当前设备相应的尺寸 devices只有选择了universal(通用)才可以让iPhone和iPad共用界面或者说不同尺寸的设备共用界面 IQKeyboardManager 必须是在push或者present的VC的视图上才可以自动调整位置 事后问过作者，说怎么都可以，但是我用的版本却实不行，作者给意见，可以考虑addChildViewCOntroller 从UINavigationController里出来的UIViewController无法不会执行shouldAutorotate,这种情况必须自定义一个继承UINavigationController的类 要实现UITableViewCell的编辑必须实现下面两个方法 (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath; (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath; 关于堆栈的理解 ：栈 — 战死 栈是死的，一般是提前分配好的，除非你malloc出来，堆的可控性就比较强，也就是自己控制它的创建，当然它的消亡也应该你来控制举个小栗：在一个函数中定义了 NSArray *a = [[NSArray alloc] init] a是个指针，他就是放在栈中的，但是它指向的那个数组就是存在堆中的。 objective-c因为字符串比较特殊，所以在写正则的时候，碰到转义字符必须多加一个”\\”，比如：全数字字符：@”^\\\\d\\+$” UITableView竟然被我发现了一个新用法（当然这个用法是旧的），它在编辑状态下可以左边显示圆圈，didSelected会自动选中，再按一次didDeselect会自动消失 下面这句话的意思是获取aView在window中的位置，注意最前边是aView的父视图 [aView.superview convertPoint:aView.frame.origin toView:nil]; UIView不能同事加多个由make生成的transform,如果加多个，第二个应该用原始方法，如下 self.contentViewContainer.transform = CGAffineTransformMakeTranslation(point.x, 0); self.contentViewContainer.transform = CGAffineTransformScale(self.contentViewContainer.transform,scale, scale); extern 是表明这个这个变量是全局的，在其他类里也可以使用这个变量不必把首次声明这个变量的类引入就行，但是必须得再次声明，static是仅限于此类里使用，其他类要想使用必须引入该类 图片的坐标原点在左下角 关于刷新子视图 -layoutSubviews方法：这个方法，默认没有做任何事情，需要子类进行重写-setNeedsLayout方法： 标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，但layoutSubviews一定会被调用-layoutIfNeeded方法：如果，有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews）如果要立即刷新，要先调用[view setNeedsLayout]，把标记设为需要布局，然后马上调用[view layoutIfNeeded]，实现布局 我勒个去哎，self.navigationController.toolbarHidden = NO 这样可以在View下边有显示一个toolbar哎，这个是可以利用的哟，完成任务必须抽时间好好研究一番，新发现啊 下面的代码输出什么 @implementation Son : Father - (id)init{ self = [super init]; if (self) { NSLog(@&quot;%@&quot;, NSStringFromClass([self class])); NSLog(@&quot;%@&quot;, NSStringFromClass([super class])); } return self; } @end 答案：都输出”Son”解释：objc中super是编译器标示符，并不像self一样是一个对象，遇到向super发的方法时会转译成objc_msgSendSuper(…)，而参数中的对象还是self，于是从父类开始沿继承链寻找- class这个方法，最后在NSObject中找到（若override）此时，[self class]和[super class]已经等价了。 所以，子类调用父类的某个方法，父类的这个方法又调用了一个跟子类有相同名字的某个方法，相当于子类直接调用了这个方法 UITextField是有leftView和rightView的，可以利用leftView在添加了背景图片后添加左边留白，但是得注意要设置属性 leftViewMode = UITextFieldViewModeAlways load方法会在类实例话的时候调用，如果要用runtime黑魔法的话就可以在这里用。initializer方法会在第一次调用该类的方法时调用这个方法，属于懒加载 UITableView的header是searchBar的时候拖拽时searchBar背景会被拉伸 视图控制器切换方法 - (void)transitionFromViewController:(UIViewController *)fromViewController toViewController:(UIViewController *)toViewController duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion NS_AVAILABLE_IOS(5_0); 不用你再去给容器视图添加(addSubView)和删除(removeFromSuperView)子视图，它会帮你处理好 哈哈哈，XCode好傻哟，如果你在.m文件里提前有了 setX和x方法，然后才在.h文件里用@property声明x属性，.m里就不允许你使用_x这个变量。此时，@synthesize 就派上了用场。@dynamic与@synthesize的区别在于：使用@synthesize编译器会确实的产生getter和setter方法，而@dynamic仅仅是告诉编译器这两个方法在运行期会有的，无需产生警告。 假设有这么个场景，B类，C类分别继承A类，A类实现某个协议（@protocol），协议中某个属性( somePropety )我不想在A中实现，而在B类，C类中分别实现。如果A中不写任何代码，编译器就会给出警告：“use @synthesize, @dynamic or provide a method implementation”这时你给用@dynamic somePropety; 编译器就不会警告，同时也不会产生任何默认代码。 UITableView在编辑状态下如果指定编辑样式是添加和删除，可以在视图上显示复选框，利用这个特性可以方便实现多选。 - (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath { return UITableViewCellEditingStyleDelete | UITableViewCellEditingStyleInsert; } 注意：以上是在UITableView单选的情况下，如果是多选就会自动出现复选框，不会执行上段代码。😂说了好多废话哟 UITableView在调用了reloadData之后，tableView会在调用完cell的高度获知contentSize之后就调用reloadData之后的语句了，完了之后才去加载cell 在 MRC 下，使用 block 说明符也可以避免循环引用。因为当 block 从栈拷贝到堆时，block 对象类型的变量不会被 retain，没有 block 说明符的对象类型的变量则会被 retian。正是由于 block 在 ARC 和 MRC 下的巨大差异，我们在写代码时一定要区分清楚到底是 ARC 还是 MRC。 实现下面的方法，我们就可以对一个类进行使用想NSArray和NSDictionary那样的语法糖用下标或者key来存取数据了, so cool - (id)objectAtIndexedSubscript:(NSUInteger)idx; - (void)setObject:(id)objatIndexedSubscript:(NSUInteger)idx; - (void)setObject:(id)objforKeyedSubscript:(id &lt;NSCopying&gt;)key; - (id)objectForKeyedSubscript:(id)key; CALayer的border是出现在layer内部的，比如说layerWidth为10,那么border就会占据layer的content的四周宽度为10的空间。 系统视频的上传必须拷贝到沙盒目录中才能上传。😥 手撸NSLayoutConstraint需要注意firstItem和secondItem的顺序 注意了，注意了，keyWindow不知道什么时候会被系统干掉，所以把hud加在keyWindow上的时候一定要注意哦。最近遇到的在把mov转换成mp4的时候系统起了个异步线程，然后kenWindow就被干掉了。 用CGContextClearRect就可以实现画一张中间透明的图片了。 想知道某个变量在程序调试时的状态，可以用借助dispatch_source_t 监控调试开始，打印变量 from dispatch_queue_t queue = dispatch_get_main_queue(); static dispatch_source_t source = nil; __typeof(self) __weak weakSelf = self; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGSTOP, 0, queue); if (source) { dispatch_source_set_event_handler(source, ^{ NSLog(@&quot;Hi, I am: %@&quot;, weakSelf); }); dispatch_resume(source); // 10 } }); 当UINavigationController push或者pop操作时NavigationBar右侧底部会变灰，解决这种问题需要把最接近当前vc的view的view的背景色修改一下就可以了。 企业账户 往App Store上发布应用必须是Agent账户 用Xcode写C，即使仅仅有C也要把Compile Sources As改为Objective C++ 我一直以为下边的代码是默认的，然而并不是，需要明确写出来。😂self.tableView.rowHeight = UITableViewAutomaticDimension; CALayer对path的动画执行完后path为初始值,如果想要最后停留住状态就可以把初始值设为toValue的值 iOS11的本地通知要想在前台显示必须实现代理willPresent的方法,文档有说明的,记住 像素就是绘画的基本单元，就是一个方格，但是并不一定是一个物理点，在高清屏上是有多个包含多个物理点的。DPI就是每英寸有多少个像素。分辨率在用ps的设计那里就是DPI，但是一般在移动开发那里就是图片的长宽。 关于在Swift中self.property和property，提倡不用self，这样如果在闭包中使用的属性是属于当前的实例对象时编译器就会报错，你就必须加上self，当你加上self的时候你就意识到self要被循环引用了，你就知道要处理这个问题了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactiveCocoa解读-订阅信号]]></title>
    <url>%2F2018%2F11%2F09%2FReactiveCocoa%E8%A7%A3%E8%AF%BB-%E8%AE%A2%E9%98%85%E4%BF%A1%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[信号(Signal)和订阅者(Subscriber)是在ReactiveCocoa( 下文简称RAC)的相关资料中提到最多的概念了，但因为是从英文语境中直接翻译过来的，让国内大部分开发者对订阅信号一时难以理解，即使掌握了RAC的用法对此还是模棱两可。今天，我们尝试从RAC的源码去解读，看看订阅信号到底是个啥子过程。 先上一段RAC最简单的使用方法。 RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { [subscriber sendNext:@&quot;钢铁锅&quot;]; [subscriber sendNext:@&quot;含眼泪喊修瓢锅&quot;]; [subscriber sendNext:@&quot;坏缺烂角的换新锅瓢乱放&quot;]; [subscriber sendNext:@&quot;哎...哎,哎,谁的鞋,不要乱扔...&quot;]; return [RACDisposable disposableWithBlock:^{ NSLog(@&quot;曲终人散，抹点药酒&quot;); }]; }]; [signal subscribeNext:^(id x) { NSLog(@&quot;我听到:%@&quot;,x); }]; 信号是信息的载体 对应上边的代码，我们创建了一个信号 signal，他承载着 钢铁锅 含眼泪喊修瓢锅 坏缺烂角的换新锅瓢乱放 哎...哎,哎,谁的鞋,不要乱扔...这些信息。 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe { RACDynamicSignal *signal = [[self alloc] init]; signal-&gt;_didSubscribe = [didSubscribe copy]; return [signal setNameWithFormat:@&quot;+createSignal:&quot;]; } 创建信号很简单，其实就是创建了一个实例对象，并把将来有可能进行的一系列操作didSubscribe这个block记录下来，等发生了订阅行为时就会执行这些操作。有人会问RACDisposable是什么东西，其实从字面就可以理解，销毁，它封装了当订阅行为消失时一些应该做的操作，当然像一开始的代码这种只是打印消息的操作其实是没必要的，所以这里可以返回nil。那什么时候订阅行为消失呢，当订阅者调用了sendError:或者sendCompleted方法时表示订阅行为就消失了，相应的dispose就会执行了，做一些清理操作。如下面的代码： RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { [subscriber sendNext:@&quot;钢铁锅&quot;]; [subscriber sendNext:@&quot;含眼泪喊修瓢锅&quot;]; [subscriber sendError:[NSError errorWithDomain:@&quot;singing&quot; code:748 userInfo:@{@&quot;reason&quot;:@&quot;麦克被歌迷拔掉了&quot;}]]; [subscriber sendNext:@&quot;坏缺烂角的换新锅瓢乱放&quot;]; [subscriber sendNext:@&quot;哎...哎,哎,谁的鞋,不要乱扔...&quot;]; [subscriber sendError:NULL]; // [subscriber sendCompleted]; return [RACDisposable disposableWithBlock:^{ NSLog(@&quot;曲终人散，抹点药酒&quot;); }]; }]; 当然如果这两个方法如果你都不调用，那么当订阅者超出了自己的生命周期调用其dealloc方法时这个dispose也会执行。所以RACDisposable在RAC里使用非常广泛，比如在NSNotificationCenter的RAC扩展中用于取消观察者，在UITextField和UITextView的扩展里取消代理等等。 说了半天大家可能会问，订阅者在哪里？别急，看下面: [signal subscribeNext:^(id x) { NSLog(@&quot;我听到:%@&quot;,x); }]; 当这句代码执行时就发生了订阅行为。其内部实现是这样： - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock { NSCParameterAssert(nextBlock != NULL); //看到了吗？我在这里，我就是订阅者。我把 nextBlock保存了下来。 RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL]; return [self subscribe:o]; } - (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber { NSCParameterAssert(subscriber != nil); RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable]; //加工了一下，变成了RACPassthroughSubscriber,关于它的作用我们在以后的文章总具体场景下再讲述，现在你只需记住一个更具体的RACSubscriber子类就行了。 subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable]; //还记得信号在一开始创建时就存下来的那个block吗，就是这个didSubscribe if (self.didSubscribe != NULL) { RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^{ //在这里支行了信号一开始创建的block，并获得了它返回的RACDisposable RACDisposable *innerDisposable = self.didSubscribe(subscriber); [disposable addDisposable:innerDisposable]; }]; [disposable addDisposable:schedulingDisposable]; } return disposable; } 看到这里你可能有产生了很多疑问，且听我慢慢道来。首先你在头脑里先产生这个场景：生成了一个subscriber(代号007)，它保存了一个nextBlock：^(id x) { NSLog(@&quot;我听到:%@&quot;,x);},然后当前这个信号开始执行didSubscribe这个block: ^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { [subscriber sendNext:@&quot;钢铁锅&quot;]; [subscriber sendNext:@&quot;含眼泪喊修瓢锅&quot;]; [subscriber sendNext:@&quot;坏缺烂角的换新锅瓢乱放&quot;]; [subscriber sendNext:@&quot;哎...哎,哎,谁的鞋,不要乱扔...&quot;]; [subscriber sendCompleted]; return [RACDisposable disposableWithBlock:^{ NSLog(@&quot;曲终人散，抹点药酒&quot;); }]; } 注意，007被当作参数传了进去，也就是调用sendNext:这个方法的都是007，还记得007保存的那个nextBlock吗，此时在sendNext:内部就是执行了这个nextBlock，传进去了钢铁锅 含眼泪喊修瓢锅 坏缺烂角的换新锅瓢乱放 哎...哎,哎,谁的鞋,不要乱扔...这些信息。这样作为开发者的你就收到了订阅者发给你的有用信息，你就“听”到了一首美妙的歌曲。 整个一个订阅流程就这样结束了，当然你会发现在你的代码中subscriber始终都没暴露出来，这也是造成你疑惑的原因，那么我问你，你需要的是subscriber呢，还是subscriber发给你的信息呢？因为我们需要的只是信息，所以完全没必要让我们知道subscriber的存在。所谓的订阅者也就是subscriber其实就是起了一个中间人的作用，获取信号(或者叫信号源更好理解)里的信息，然后发送到需要的地方。 RACCompoundDisposable(RACDisposable的子类)应该是大家的另一个疑问，它有一个方法addDisposable:可以添加另一个RACDisposable，它的最终形态是一个树形结构，第一个RACCompoundDisposable存了若干个RACDisposable或者RACCompoundDisposable，相应的RACCompoundDisposable又存了若干个RACDisposable或者RACCompoundDisposable…每个元素里边存的都是一些block形式存在的清理操作，这样当执行树的根节点的dispose时，整棵树就会按顺序执行清理操作了。 那么，讲到这里就先告一段落了，等有时间我会把RAC更复杂场景下的使用流程介绍给大家。 希望能对您有一点帮助。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>ReactiveCocoa</tag>
        <tag>RAC</tag>
      </tags>
  </entry>
</search>
